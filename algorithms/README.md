### 递归

递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。递归通常涉及函数调用自身。

每个递归函数都必须要有边界条件，即一个不再递归调用的条件（停止点），以防止无限递归。

常见的递归用法示例：

- avaScript 调用栈大小的限制。
  - 根据操作系统和浏览器的不同，具体数值会所有不同，但区别不大；
  - ES6 有尾调用优化，递归并不会更慢。但是在其他语言中，递归通常更慢。
- 斐波那契数列（杨辉三角）
- 阶乘

### 分治法

分治法是建基于多项分支递归的一种很重要的算法范式。

字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

常见的分治法示例

- 归并排序

- 快速排序

### 动态规划

动态规划（Dynamic Programming， DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。

要注意动态规划和分而治之（归并排序和快速排序算法中用到的那种）是不同的方法。

分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。

用动态规划解决问题时，要遵循三个重要步骤：

1. 定义子问题；
2. 实现要反复执行来解决子问题的部分；
3. 识别并求解出边界条件。

能用动态规划解决的一些著名的问题如下。

- 背包问题：给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。

- 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。

- 矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。
  相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。

- 硬币找零：给出面额为 d1…dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。

- 图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。比如`Floyd-Warshall`算法。

### 贪心算法

贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。

常见的贪心算法示例：

- 硬币找零
- 背包问题
- Dijkstra 算法
- Prim 算法
- Kruskal 算法
