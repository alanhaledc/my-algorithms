/*
 * @lc app=leetcode.cn id=1705 lang=typescript
 *
 * [1705] 吃苹果的最大数目
 *
 * https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/description/
 *
 * algorithms
 * Medium (39.27%)
 * Likes:    80
 * Dislikes: 0
 * Total Accepted:    9.1K
 * Total Submissions: 23.4K
 * Testcase Example:  '[1,2,3,5,2]\n[3,2,1,4,2]'
 *
 * 有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i]
 * 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且
 * days[i] == 0 表示。
 *
 * 你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。
 *
 * 给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。
 *
 *
 *
 * 示例 1：
 *
 * 输入：apples = [1,2,3,5,2], days = [3,2,1,4,2]
 * 输出：7
 * 解释：你可以吃掉 7 个苹果：
 * - 第一天，你吃掉第一天长出来的苹果。
 * - 第二天，你吃掉一个第二天长出来的苹果。
 * - 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。
 * - 第四天到第七天，你吃的都是第四天长出来的苹果。
 *
 *
 * 示例 2：
 *
 * 输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]
 * 输出：5
 * 解释：你可以吃掉 5 个苹果：
 * - 第一天到第三天，你吃的都是第一天长出来的苹果。
 * - 第四天和第五天不吃苹果。
 * - 第六天和第七天，你吃的都是第六天长出来的苹果。
 *
 *
 *
 *
 * 提示：
 *
 *
 * apples.length == n
 * days.length == n
 * 1 <= n <= 2 * 10^4
 * 0 <= apples[i], days[i] <= 2 * 10^4
 * 只有在 apples[i] = 0 时，days[i] = 0 才成立
 *
 *
 */

export {};

// @lc code=start
class Heap<T> {
  items: T[] = [];
  compare: (a: T, b: T) => boolean;

  constructor(compare: (a: T, b: T) => boolean = (a, b) => a > b) {
    this.items = [];
    this.compare = compare;
  }

  get size(): number {
    return this.items.length;
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }

  private parent(index: number): number {
    if (index !== 0) {
      return Math.floor((index - 1) / 2);
    } else {
      return 0;
    }
  }

  private leftChild(index: number): number {
    return index * 2 + 1;
  }

  private rightChild(index: number): number {
    return index * 2 + 2;
  }

  push(val: T) {
    this.items.push(val);
    this.siftUp(this.size - 1);
  }

  pop(): T | undefined {
    const res = this.peek();
    this.swap(this.items, 0, this.size - 1);
    this.items.pop();
    this.siftDown(0);
    return res;
  }

  peek(): T | undefined {
    if (!this.isEmpty()) {
      return this.items[0];
    }
  }

  private siftUp(index: number): void {
    while (
      index > 0 &&
      this.compare(this.items[index], this.items[this.parent(index)])
    ) {
      this.swap(this.items, index, this.parent(index));
      index = this.parent(index);
    }
  }

  private siftDown(index: number): void {
    while (this.leftChild(index) < this.size) {
      let idx = this.leftChild(index);

      if (idx + 1 && this.compare(this.items[idx + 1], this.items[idx])) {
        idx = this.rightChild(index);
      }
      if (this.compare(this.items[index], this.items[idx])) {
        break;
      }
      this.swap(this.items, index, idx);
      index = idx;
    }
  }

  private swap(arr: T[], i: number, j: number): void {
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function eatenApples(apples: number[], days: number[]): number {
  let res = 0;
  const heap = new Heap<number[]>((a, b) => a?.[0] < b?.[0]);
  let n = apples.length;
  let i = 0;
  while (i < n) {
    while (!heap.isEmpty() && heap.peek()![0] <= i) {
      heap.pop();
    }
    let rottenDay = i + days[i];
    let count = apples[i];
    if (count > 0) {
      heap.push([rottenDay, count]);
    }
    if (!heap.isEmpty()) {
      const arr = heap.peek()!;
      arr[1]--;
      if (arr[1] === 0) {
        heap.pop();
      }
      res++;
    }
    i++;
  }
  while (!heap.isEmpty()) {
    while (!heap.isEmpty() && heap.peek()![0] <= i) {
      heap.pop();
    }
    if (heap.isEmpty()) {
      break;
    }
    const arr = heap.pop()!;
    let cur = Math.min(arr[0] - i, arr[1]);
    res += cur;
    i += cur;
  }
  return res;
}
// @lc code=end
